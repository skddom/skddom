#  DS Form

1. [Подключение](#include)
2. [Инициализация скрипта](#init)
	+ [Плагин jQuery](#plugin)
	+ [Ленивые всплывающие формы](#lazymodals)
	+ [Быстрое создание кнопок и блоков](#quickforms)
	+ [Настройки формы при инициализации](#parameters)
	+ [Особенности объектной модели](#objective)
3. [Автозаполнение полей](#dsconfig)
4. [Callback функции](#callbacks)
	+ [Пример использования: вставка картинки в форму](#includeimage)
5. [Подключаемые плагины](#featured)
	+ [Стилизация полей типа select, checkbox, file  и др.](#styler)
	+ [Маска ввода для поля](#inputmask)
	+ [Календарь с выбором даты](#calendar)

<a name="include">
## Подключение
</a>

Скрипт формы подключается после jQuery (обычно в `<head>`):

```html
<script type="text/javascript" src="/ds-comf/ds-form/js/dsforms.js"></script> 
```

Корневую директорию (по умолчанию `/ds-comf/ds-form/`) всех файлов дистрибутива можно указать в файле `js/dsforms.js`, если требуется:

```js
dsformROOT = '/mydir/';
```

Минимальная версия фреймворка: 1.5. Если jQuery не подключен или версия ниже требуемой, то в консоли выводится ошибка:

```
Version jQuery < 1.5 or jQuery is not found!
```

Скрипт без конфликтов подключаем так:

```html
<script type="text/javascript" src="/ds-comf/lib/jquery-1.11.3.min.js"></script>
<script type="text/javascript">
    gKweri = $.noConflict(true);
</script>
<script type="text/javascript" src="/ds-comf/ds-form/js/dsforms.js"></script>
```

Далее пользуемся переменной `gKweri`, везде где необходима нужная нам версия.

<a name="init">
## Инициализация скрипта
</a>

Назначить форму на кнопку/блок можно несколькими способами.

> **ВАЖНО!** При инициализации формы у связанного элемента (кнопки, контейнера) скриптом может устанавливаться атрибут `data-dsform-marker="1"`. Этот атрибут устанавливается, чтобы пометить элемент, как уже используемый для избежания случаев повторной инициализации, поэтому если его установить специально, форма работать не будет. 

<a name="plugin">
### Плагин jQuery
</a>

Для того, чтобы вывести форму в блоке, инициализируем элемент (группу элементов) как объект формы:

```js
$(document).ready(function(){
    $('.form-block').dsform({
        formID : 'id формы',
        modal : false,
    });
});
```

Чтобы назначить всплывающую форму по клику на элементе:

```js
$(document).ready(function(){
    $('.button').dsform({
        formID : 'id формы',
    });
});
```

> **ВАЖНО!** Контейнер для всплывающей формы создается после первого клика по соответствующей кнопке. Он добавляется в конец тега `body`. Если есть необходимость, можно создать его самостоятельно в любом месте, указав атрибут `data-dsform-id="id_формы"`. 

<a name="lazymodals">
### Ленивые всплывающие формы
</a>

Можно создать объект формы и пользоваться только его методами:

```js
var myform = $.dsform({
	formID: 'myform',
	...
	param: value
});
```

Теперь переменная _myform_ доступна нам везде (в том контексте, где была создана, как правило _window_) :

```html
<!-- Можно так -->
<button onclick="myform.show();">Показать форму</button>
<!-- или даже так -->
<script>
myform.options.clearErrors = true; // просто будем очищать ошибки
</script>

Скорость анимации: <br>
<input type="number" min="0" value="0" onchange="myform.options.animationspeed = Number(this.value);"><br>
<input type="checkbox" checked="checked" onchange="myform.options.stackErrors = this.checked;"> Группировать ошибки
<input type="submit" value="Покажите уже" onclick="myform.open();">

```

<a name="quickforms">
### Быстрое создание кнопок и блоков
</a>

Внутри скрипта есть надстройка, которая инициализирует все элементы имеющие атрибут `data-dspopup-id`, как кнопки
и имеющие `class="ds-form"` как блоки. Таким образом можно быстро создать требуемые формы вставив в нужном месте в контенте:

* для блоков

```html
<div id="id формы" class="ds-form"></div>
``` 

* для кнопок

```html
<button data-dspopup-id="id формы">Форма обратной связи</button>
``` 
Такой метод является более простым, но обладает рядом недостатков:

- не всегда есть возможность указать необходимые атрибуты, например админка может резать пустые div'ы или атрибут `data-dspopup-id`
- используются только минимальные настройки инициализации

<a name="parameters">
### Настройки формы при инициализации
</a>

Полный перечень настроек:

* **formID**: *(строка)* - id формы назначаемой на элемент
* **modal**: *(флаг)* - использовать назначенный элемент, как кнопку для всплывающей формы, по умолчанию `true`
* **additionalClass**: *(строка)* - добавляет класс контейнеру в котором находится форма
* **reload**: *(флаг)* - если `false`, то после отправки формы при повторном открытии форма не будет загружаться заново
* **stackErrors** - если `false`, то ошибки заполнения будут не собираться в конце формы, а выводиться каждая у соответствующего поля. Немного милых стилей для отбражения с `false`:

```css
.dsform-field-error {
    display: block;
    position: relative;
    max-width: 100%;
}
.dsform-field-error > span {
    background-image: linear-gradient(red, crimson);
    border-radius: 10px;
    color: white;
    display: block;
    font-size: 60%;
    font-weight: 700;
    padding: 2px 5px;
    position: absolute;
    right: 0;
    top: -8px;
}
.dsform-field-error > span::before {
    border-color: transparent transparent red;
    border-style: solid;
    border-width: 0 5px 5px;
    content: "";
    display: block;
    height: 0;
    position: absolute;
    right: 10px;
    top: -5px;
    width: 0;
}
.dsform-field-error.hint-proper > span {
    background-image: linear-gradient(yellowgreen, forestgreen);
}
.dsform-field-error.hint-proper > span::before {
    border-color: transparent transparent yellowgreen;
}
```

* **clearErrors** - если `true`, ошибки заполнения будут удалены после закрытия модального окна
* **config**: *(строка)* - строка в JSON формате, то же самое что и атрибут `data-dsconfig`, но имеет меньший приоритет
* **inputmask**: *(объект)* - объект формата `{'имя поля': {объект настроек}}`, для inputMask, см. "Подключаемые плагины"
* **dates**: *(объект)* - объект формата `{'имя поля': {объект настроек}}`, для dscalendar, см. "Подключаемые плагины"
* **showLoader**: *(флаг)* - определяет, показывать ли анимацию загрузки на месте "кнопки отправить", по умолчанию `true`
* **useFormStyler**: *(строка или флаг)* - определяет использовать ли плагин Form Styler для формы, по умолчанию `false`. Если указать true, то стилизует все возможные элементы, можно указать строку с селекторами, чтобы ограничить стилизацию
* **formstyler**: *(объект)* - настройки специфичные для плагина Form Styler, см. "Подключаемые плагины"
* **onInit**: *(функция)* - функция по событию связывания элемента и формы, срабатывает после загрузки документа, поэтому имеет практическое значение только для всплывающих форм , см. "[Callback функции](#callbacks)"
* **onLoad**: *(функция)* - функция по событию загрузки кода формы, срабатывает при обновлении формы, а именно:
	- при загрузке страницы у блоков
	- для всплывающих форм срабатывает каждый раз, когда происходит клик по новой кнопке для формы, например если сделать две кнопки которые будут открывать одну и ту же форму и нажимать их поочередно. При клике по одной и той же кнопке загрузка формы происходит только в первый раз.
	- при клике на элемент с классом `repeatform`, который перезагружает форму.
* **onShow**: *(функция)* - функция сработает по завершению анимации открытия модального окна.
* **onSuccess**: *(функция)* - функция сработает, если сервер сообщит об успешной отправке письма, например если письмо действительно отправилось
* **onFail**: *(функция)* - функция сработает, если в форме были ошибки заполнения полей
* **onClose**: *(функция)* - функция сработает по завершению анимации закрытия модального окна
* **onServerError**: *(функция)* - функция сработает, если сервер сообщит о неудачной отправке письма
* **animationspeed**: *(число)* - скорость анимации модального окна в миллисекундах, на всякий случай
* **closeonbackgroundclick**: *(флаг)* - определяет будет ли окно закрываться по клику на фоне, по умолчанию `true`


Пример инициализации:

```js
$('.test-open').dsform({
    formID: 'feedback',
    additionalClass: 'my-class', 
    inputmask: {'phone': {placeholder: '#'}},
    dates: {'eventdate': '2.12.2015',
            'leavedate': 3,
            },
    config: '{"product": "' + $('h1').eq(0).text() + '"}',
    animationspeed: 0, 

    useFormStyler: 'select#stylish',

    onLoad: function () { 
        console.log('Загрузили');
    },
    onShow: function () {
        console.log('Открыли');
    },
    onSuccess: function () {
        console.log('Получилось!');
    },
    onFail: function () {
        console.log('Взрослых попроси заполнить');
    },
    onClose: function () {
        console.log('Закрыли');
    },
});
```

<a name="objective">
### Особенности объектной модели
</a>

Все формы будут вести себя независимо друг от друга, так как работают в контексте своих элементов. Инициализируем две кнопки, которые будут открывать одну и ту же форму:
```js
$('.btn').dsform({formID: 'sample'});

$('.btn-neat').dsform({
	formID: 'sample',
	additionalClass: 'neat',
	useFormstyler: true,
});

```
В данном примере при нажатии первой кнопки будет всплывать обычное модальное окно, при нажатии второй кнопки,
 несмотря на то что обе используют один и тот же контейнер, будет использоваться стилизация и добавляться класс.
Несколько одинаковых блоков будет проходить валидацию и отправляться независимо друг от друга, несмотря на одинаковые  атрибуты name у соответствующих полей.


<a name="dsconfig">
## Автозаполнение полей
</a>

Автозаполнение полей происходит, если у элемента указывается атрибут `data-dsconfig` со значением в виде валидной JSON строки: 

```html
<button data-dspopup-id="primer" data-dsconfig="{'name':'Иннокентий','gorod':{'0':{'text':'Воронеж','value':'Voronez','select':''}, '1':{'text':'Урюпинск','value':'Urupinsk'}}}">ClickMe</button>
```

Преимущества такого способа это простота, доступность, возможность указать разные значения для схожих элементов. Недостатками являются статичность значений, админка может резать атрибут.

Использование параметра `config` при инициализации позволяет динамически определять содержимое для заполнения, например используя траверсинг:
```html
<div class="productunit">
	<div class="product-name">Макарошка</div>
	<div class="prices">
		100 руб. <button>Хочу!</button>
	</div>
</div>

<div class="productunit">
	<div class="product-name">Пюрешка</div>
	<div class="prices">
		200 руб. <button>Хочу!</button>
	</div>
</div>

<script>
$('.productunit .prices>button').each(function () {
	$(this).dsform({
	   formID: 'button',
	   config: '{"prod":"'+ $(this).parents('.productunit').find('.product-name').text() +'"}',
    });
});
</script>
```

Этот способ подходит если, например товары сделаны статикой, чтобы не прописывать атрибут вручную.

> **ВАЖНО!** Если значения для заполнения поля указано и в скрипте и атрибутом у элемента, атрибут будет приоритетным, причём следует учесть, что меняется вся JSON строка, а не только значение для конкретного поля.

<a name="callbacks">
## Callback функции
</a>

Callback функции возможны на всех основных событиях работы скрипта (см. Настройки формы при инициализации). В ранних версиях скрипта они выполнялись в контексте объекта window, гораздо эффективнее callback функции можно использовать, выполняя в контексте объекта формы.  Это делает доступным, например, траверсинг и публичные методы и свойства объекта. Сам объект формы в функциях доступен через `this`.

**Свойства:**

* Все настройки формы при инициализации доступны в _**this**.options_. Можно переопределять свойства, тем самым изменяя дальнейшую работу скрипта. Например, по событию `onServerError` (невозможно отправить письмо) изменить функцию по событию `onClose`, в которой меняем `onShow`:

```js
onServerError: function(){   // если произойдет ошибка
	this.sended = true;    // ставим флаг, что форма отправилась (так как на самом деле нет)
	this.options.reload = true; // эта опция перезагрузит форму при повторном открытии после отправки
	this.options.onClose = function(){  // уведомляем пользователя об альтернативных вариантах связи
		alert('Стойте! По техническим причинам нет возможности отправить письмо через эту форму. Напишите нам на zelda@hyrule.com.');
		this.options.onClose = undefined;  // уведомить надо один раз, поэтому переопределяем функцию в самой себе
		this.options.onLoad = function(){  // теперь будем подменять контент, чтобы форма не выводилась
			this.form.html('К сожалению, отправить письмо через эту форму сейчас нет возможности. <br /> Напишите нам на  <big><a href="mailto:zelda@hyrule.com">mailto:zelda@hyrule.com</a>');
		}
	}
}
```

* **this**. container _(объект jQuery)_ - элемент  внутри которого находится &lt;form&gt;, т.е. само окно или блок.
* **this**.form _(объект jQuery)_ - элемент `<form>`, после отправки (если не было ошибок заполнения) удаляется.
* **this**. _(объект jQuery)_ - элемент отчета об отправке. Например, подменяя его контет можно сократить  приведённую выше функцию onServerError на две строки.
* **this**.config _(строка)_ -  строка JSON формата, см. "Автозаполнение полей". Например, можно сделать функцию которая будет автоматически подставлять последнее введённое пользователем имя.
* **this**.element _(объект jQuery)_ - элемент, на который назначена форма, в случает с блоками соответствует **this**. container , для всплывающих форм, кнопка вызывающая форму.

**Методы:**

* **this**.open() - откроет всплывающую форму
* **this**.close() - закроет всплывающую форму
* **this**.getPath(_объект jQuery_) - возращает _строку_ - путь до элемента (`html > body > div#mydiv_id.mydiv_class`), если аргумент не указан вернет путь до **this**.element
* **this**. getForm()  - обновляет форму
* **this**.field(_строка_ имя поля ) - принимает имя поля, возвращает найденный элемент в  виде jQuery объекта. Если в начале стоит **#**, то ищет по id. Добавлено, чтобы не писать `this.form.find('[name="myname"]')`

**Аргументы**

На данный момент все функции могут вызываться с одним аргументом, который используется в качестве псевдонима JQuery (как $, например). Иногда это просто короче чем писать `gKweri`, иногда бывает полезно, если нужно вызвать функции, используя ту же самую версию jQuery, что использует dsform:

```js
/* на странице треш, угар и содомия: несколько разных версий jQuery, mootools, 
поэтому форму ранее подключили через noConflict */
...
onLoad: function($) { // можно назначить любое имя
	console.log(jQuery.fn.jquery) // тут неизвестно что будет
	console.log($.fn.jquery); // а тут все чисто, все равно что написать вот так, но короче:
	console.log(gKweri.fn.jquery);
}
```

<a name="includeimage">
### Пример использования: вставка картинки в форму
</a>

Список карточек каталога имеет следующую структуру:

```html

<div class="item" id="item1">
	<div class="image">
		<img src="image1.jpg" alt="Ложка деревянная" />
	</div>
	<div class="buybuttons">
		<button class="add_to_cart">В корзину</button>
		<div style="position: absolute; bottom: 0; left: calc(50% - 40px);">
			<a class="buy1click">Купить в 1 клик</a>
		</div>
	</div>
</div>
...

<div class="item" id="itemN">
	<div class="image">
		<img src="imageN.jpg" alt="Кружка деревянная" />
	</div>
	<div class="buybuttons">
		<button class="add_to_cart">В корзину</button>
		<div style="position: absolute; bottom: 0; left: calc(50% - 40px);">
			<a class="buy1click">Купить в 1 клик</a>
		</div>
	</div>
</div>
```

Интересующая нас форма всплывает при клике на ссылку "Купить в 1 клик". В шаблоне через `freearea` создадим родительский элемент для картинки с каким нибудь однозначным селектором например 

```html
<div class="the_image"></div>
```

Чтобы  вставить в форму картинку соответствующую именно той карточке, кнопка который была нажата, пишем callback по событию `onLoad`:

```js
onLoad: function(){
var fo = this; // на всякий случай присваиваем новой переменной объект формы (для каждой кнопки он уникален)

fo.element                                             // именно та ссылка на которой был клик
.parents('.item')                                     // ищем её родителя с эти классом
.find('.image>img')                                // теперь внутри родителя ищем картинку
.clone()                                                   // клонируем её
.appendTo(fo.form.find('.the_image'));   // вставляем клон в наш контейнер.
}
```

<a name="featured">
## Подключаемые плагины
</a>

На данный момент скрипт автоматически подключает при необходимости другие скрипты, список которых возможно расширить. 

Перед подключением скрипт сначала пытается найти и использовать ранее подключённый плагин. Если требуемый плагин уже был подключен в консоли выводится информация: 

```
DSFORM: formstyler was loaded before
```

Для некоторых плагинов требуется раскомментировать css файл в папке стилей. Ссылки на документацию по плагинам можно получить, выполнив в консоли:

```js
$.dsform.uses()
```

> **ВАЖНО!** Плагины подключаются в конец head и могут не работать, если, например, переопределяется jQuery. Если скрипт формы подключен с помощью  noConflict, можно поменять аргумент jQuery самоисполняющейся функции в конце кода плагинов на gKweri.
> Также можно попробовать подключить скрипты самостоятельно в код страницы. 

<a name="styler">
### Form Styler
</a>

Плагин jQuery для изменения внешнего вида:

* `input[type="radio"]`
* `input[type="checkbox"]`
* `input[type="file"]`
* `select`

Подключается автоматически если указан параметр `useFormStyler` при инициализации формы. Значением должно быть `true`, если требуется использовать плагин для всех поддерживаемых типов полей, либо _строка с селектором_, если требуется использовать плагин только для конкретных элементов.
Также при инициализации можно указать дополнительные настройки в параметре `formstyler`, например:

```js
$('.btn').dsform({
	formID: 'sample',
	useFormstyler: true,
	formstyler: {
		onSelectOpened: function () { console.log('Select opened!'); },
		idSuffix: '-dsstyle'
	}
});

```

Подробная документация по плагину доступна на http://dimox.name/jquery-form-styler

#### Особенности

Плагин использует jQuery > 1.7. Если версия фреймворка ниже требуемой, то в консоли выводится сообщение, форма продолжит работать.

Версия в дистрибутиве немного изменена: у плагина есть баг — даже если у `select` есть выбранная опция, изначально выводилась заглушка "Выберите пункт". Убрана.

<a name="inputmask">
### Input Mask
</a>

Input Mask — форк плагина Masked Input. Подключается автоматически, если у поля `input[type="text"] `есть атрибут `data-dsform-mask`.

Атрибут с нужным значением необходимо указать в массиве `attributs` поля в шаблоне формы.

```php
'data-dsform-mask' => '+7 (999) 999-99-99',
```

Можно указать поле и опции плагина в параметре inputmask при инициализации:

```js
$('.btn').dsform({
	formID: 'sample',
	inputmask: {
		'serial': {
			mask: '999-AAA',
			placeholder: ' '
		}	
	}
});
```

Как видно из примера, есть даже возможность переназначить маску изначально указанную в атрибуте. Также плагин использует опции указанные, как атрибуты поля. 

Приоритетность опций такая (от низшего к высшему):
 
* атрибут `data-dsform-mask`
* значения, определенные при инициализации в параметре `inputmask`

Плагин имеет очень много возможностей и настроек, подробная документация на https://github.com/RobinHerbots/jquery.inputmask

#### Особенности

Версия в дистрибутиве немного изменена, для поддержки jQuery 1.5 (методы `.on()` и `.off()` заменены на `.bind()` и `.unbind()`).

<a name="calendar">
### DScalendar
</a>

Добавляет кнопку показывающую календарь для выбора даты к полю `input[type="text"]`. Подключается автоматически, если у поля существует атрибут `data-dsform-date`, в котором указывается формат вставляемой даты:


```php
'data-dsform-date' => '{D} {MMMMM} {YYYY} года', //выведет 5 Июля 2014 года
```

Псевдонимы данных:

- {D} - день без нуля
- {DD} - день с нулём
- {M} - месяц  без нуля
- {MM} - месяц с нулём
- {MMM} - месяц вида "янв" или "мар", с маленькой буквы
- {MMMM} - месяц вида "Сентябрь" с большой
- {MMMMM} - месяц  вида "Июня" в р.п. с большой
- {YY} - последние цифры года
- {YYYY} - год 

При инициализации можно указать настройки для календаря, в формате 'имя поля': {param: value} : 

```js
$('.btn').dsform({
	formID: 'sample',
	dates: {
		'fieldname1': { udate: '07.1964'},  // календарь будет установлен на этот месяц
		'fieldname2': { multiple: 2 }, // будет выводиться два календаря, на текущий и на следующий месяцы
		'fieldname3': { udate: -3    }          // сдвигает относительно текущей даты на указанное число месяцев
	}
});
```

#### Особенности

Скрипт был написан специально для формы и имеет минимум возможностей, работает без фреймворков.